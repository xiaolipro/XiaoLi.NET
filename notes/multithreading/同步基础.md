## 基本概念
**同步（synchronization）**：为期望的结果协调线程的行为。 当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。

**阻塞（block）**：当线程的执行由于某些原因被暂停，比如【信号构造】或【锁构造】时，比如调用Thread.Sleep，Task.Wait，或者通过Join方法等待其它线程结束时，则认为此线程被阻塞（blocked）。

阻塞会在以下 4 种情况下解除（电源按钮可不能算╮(╯▽╰)╭）：

* 阻塞条件被满足
* 操作超时（如果指定了超时时间）
* 通过Thread.Interrupt中断
* 通过Thread.Abort中止

**挂起（suspend）**：类似阻塞，但是不同于阻塞的是挂起会立刻让出（yields）其处理器时间片（timeslice），比如await（编译器将代码转换为状态机，它将跟踪类似：到达 await 时暂停执行以及后台作业完成时继续执行。从理论上讲，这是[异步的承诺模型](https://en.wikipedia.org/wiki/Futures_and_promises)的实现。）不要阻塞，而要 await！
```c#
static async Task<Toast> MakeToastWithButterAndJamAsync(int number)
{
    // do samething..
    var toast = await ToastBreadAsync(number);
    // do samething..
    return toast;
}
```
**锁构造（lock）**：锁能够限制同一时刻可以执行某些指令或是某段代码的线程数量。排他锁是最常见的，它只允许同一时刻至多有一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。
一般的排他锁有lock（Monitor.Enter/Monitor.Exit）、Mutex、SpinLock，非排他锁有Semaphore、SemaphoreSlim以及reader/writer lock。

**信号构造（signal）**：信号构造可以使一个线程【挂起】，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：事件等待句柄（event wait handle ）和Monitor类的Wait / Pulse方法。
Framework 4.0 加入了CountdownEvent与Barrier类。

**自旋（spinning）**：有时线程必须阻塞/暂停，直至条件被满足，【信号构造】或【锁构造】可以实现，但在等待条件能够在微秒级的时间被满足时，
自旋往往更加高效，因为它避免了上下文切换带来的昂贵开销。
```c#
while (!condition);
```
自旋往往与阻塞组合使用，防止cpu浪费
```c#
while (!condition) Thread.Sleep (10);
```
**线程状态（thread state）**：Unstarted、Running、WaitSleepJoin、Stopped。。

### Atomically

**原子性（atomically）**：如果一组变量总是在相同的【锁构造】内进行读写，就可以称为原子性读写
```c#
lock (locker) { if (x != 0) y /= x; }
```
可以说x和y是被原子的访问的，因为上面的代码块无法被其它的线程分割或抢占（cpu悲观锁/总线锁）。如果被其它线程分割或抢占，x和y就可能被别的线程修改导致计算结果无效（cpu乐观锁/缓存锁）。而现在 x和y总是在相同的排它锁中进行访问，因此不会出现除数为零的错误。

**指令原子性（instruction atomically）**：如果一条【指令】可以在 CPU 上不可分割地执行，那么它就是原子的

**指令（instruction）**：指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，CPU 通过【控制器单元】解析机器码来知道指令的内容。


## 线程安全

**线程安全（thread safe）**：指的是被任意多的线程同时执行，都可以保证正确性。

>除基本类型外，很少有类型是线程安全的，线程安全的责任基本落在开发者身上，System.Collections.Concurrent命名空间下的类型的除外。

* 线程安全最常见的手段一般是使用【**排它锁**】，将大段代码甚至是访问的整个对象封装在一个排它锁内，从而保证在高层上能进行顺序访问。
这种解决方案适用于对象的方法都能够快速执行的场景（否则会导致大量的阻塞）。
* 还有一种手段很高明，即通过【**最小化共享数据**】来减少【线程交互】，web服务器就是最好的案例，由于多个客户端请求可以同时到达，服务端方法必须保证线程安全。类似的案例还有【无状态】设计，在本质上限制了
数据交互的可能，具有良好的伸缩性（scalability）。
* 还有一种手段，【**自动锁机制（automatic locking）**】如果继承 ContextBoundObject 类并使用 Synchronization 特性，.NET Framework 就可以实现这种机制，framework全系支持，但是netcore没有，类似java的synchronized。
>尽管这样降低了开发者实现线程安全的负担，但范围过大的锁定作用域将制造出巨大的麻烦：死锁、非有意的重入以及降低并发度。这使得手动锁定在任何场景都显得更为合适，而并不仅仅只在简单的场景下（直到有更好用的自动锁机制出现）。
* 其它手段，【信号构造】，【内存屏障】，【自旋构造】。。。

## 锁构造
**同步对象（synchronized object）**：对所有参与同步的线程可见的任何对象都可以被当作同步对象使用，但有一个硬性规定：同步对象必须为引用类型。同步对象一般是私有的（因为这有助于封装锁逻辑），并且一般是一个实例或静态字段。同步对象也可以就是其要保护的对象。
```c#
class ThreadSafe
{
  List <string> _list = new List <string>();

  void Test()
  {
    lock (_list)
    {
      _list.Add ("Item 1");
      // ...
```
&emsp;&emsp;一个只被用来加锁的字段（例如前面例子中的_locker）可以精确控制锁的作用域与粒度。对象自己（this），甚至是类型，lambda 表达式或匿名方法所捕获的局部变量都可以被当作同步对象来使用：
```c#
lock (this) { ... }
// 或者：
lock (typeof (Widget)) { ... }    // 保护对静态资源的访问
```
&emsp;&emsp;这种方式的缺点在于并没有对锁逻辑进行封装，从而很难避免【死锁】与过多的【阻塞】。同时类型上的锁也可能会跨越应用程序域（application domain）边界（在同一进程内）。

### Monitor
C# 的lock语句是一个语法糖，它其实就是使用了try / finally来调用Monitor.Enter与Monitor.Exit方法：
```c#
bool taken = false;
try
{
    // JIT应该内联此方法，以便在典型情况下优化lockTaken参数的检查。
    Monitor.Enter(_locker,ref taken);
    num++;
}
finally
{
    // C# 4.0 解决锁泄露问题
    if (taken) Monitor.Exit(_locker);
}
```
Monitor是【可重入的（Reentrant）】,只有当最外层的lock语句退出或是执行了匹配数目的Monitor.Exit语句时，对象才会被解锁。
```c#
static void Main()
{
    lock (locker)  // 线程只会在第一个（最外层）lock处阻塞。
    {
        AnotherMethod();
        // 这里依然拥有锁，因为锁是可重入的
    }
}

static void AnotherMethod()
{
  lock (_locker) { Console.WriteLine ("Another method"); }
}
```
&emsp;&emsp;Monitor的性能：在一个 2010 时代的计算机上，没有竞争的情况下获取并释放锁一般只需 20 纳秒。如果存在竞争，产生的上下文切换会把开销增加到微秒的级别，并且线程被重新调度前可能还会等待更久的时间。如果需要锁定的时间很短，那么可以使用【自旋锁（SpinLock）】来避免上下文切换的开销。

&emsp;&emsp;Monitor还提供了一个TryEnter方法，允许以毫秒或是TimeSpan方式指定超时时间。如果获得了锁，该方法会返回true，而如果由于超时没有获得锁，则会返回false。TryEnter也可以以无参数的形式进行调用，这是对锁进行“测试”，如果不能立即获得锁就会立即返回false。

>如果获取锁后保持的时间太长而不释放，就会降低并发度，同时也会加大【死锁】的风险。

### Mutex

Mutex互斥体类似于Monitor，不同在于它是可以跨越进程工作。换句话说，Mutex可以是机器范围（computer-wide）的，也可以是程序范围（application-wide）的。

>没有竞争的情况下，获取并释放Mutex需要几微秒的时间，大约比lock慢 50 倍。

&emsp;&emsp;使用Mutex类时，可以调用WaitOne方法来加锁，调用ReleaseMutex方法来解锁。关闭或销毁Mutex会自动释放锁。与lock语句一样，Mutex只能被获得该锁的线程释放。

跨进程Mutex的一种常见的应用就是确保只运行一个程序实例。
```c#
// 命名的 Mutex 是机器范围的，它的名称需要是唯一的
// 比如使用公司名+程序名，或者也可以用 URL
using (var mutex = new Mutex (false, "oreilly.com OneAtATimeDemo"))
{
  // 可能其它程序实例正在关闭，所以可以等待几秒来让其它实例完成关闭
  if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false))
  {
    Console.WriteLine ("Another app instance is running. Bye!");
    return;
  }
  RunProgram();
}
```
>如果在终端服务（Terminal Services）下运行，机器范围的Mutex默认仅对于运行在相同终端会话的应用程序可见。要使其对所有终端会话可见，需要在其名字前加上Global\。


### Semaphore

信号量类似于一个通道：它具有一定的容量（capacity），并且有保安把守。一旦满员，就不允许其他人进入，这些人将在外面排队。当有一个人离开时，排在最前头的人便可以进入。

&emsp;&emsp;容量为1的的信号量就是一把互斥锁，类似mutex，不同的是信号量没有【所有者】，它是线程无关（thread-agnostic）的。任何线程都可以在调用Semaphore上的Release方法，而对于mutex，只有获得锁的线程才可以释放该锁。

>SemaphoreSlim是 standard1.0 就支持的轻量级的信号量，功能与Semaphore相似，不同之处是它对于并行编程的低延迟需求做了优化；支持在等待时指定取消标记 （cancellation token）。但它不能跨进程使用，Semaphore可以。
>
> 在Semaphore上调用WaitOne或Release会产生大概 1 微秒的开销（无竞争情况下），而SemaphoreSlim产生的开销约是其四分之一。
>
> 为什么把信号量丢到锁里面将，是因为信号量底层也是monitor，利用其可重入的特性，实现的


### 死锁

&emsp;&emsp;当两个线程等待的资源都被对方占用时（A等B，B等A），它们都无法执行，这就产生了死锁。更复杂的死锁链可能由三个或更多的线程创建。
```c#
object locker1 = new object();
object locker2 = new object();

new Thread(() =>
{
    lock (locker1)
    {
        Thread.Sleep(1000);
        lock (locker2)  // 死锁
        {
            // do something..
        }
    }
}).Start();

lock (locker2)
{
    Thread.Sleep(1000);
    lock (locker1)  // 死锁
    {
        // do something..
    }
}
```
&emsp;&emsp;CLR 不会像SQL Server一样自动检测和解决死锁。除非你指定了锁定的超时时间，否则死锁会造成参与的线程无限阻塞。（在SQL CLR 集成宿主环境中，死锁能够被自动检测，并在其中一个线程上抛出可捕获的异常。）

&emsp;&emsp;死锁是多线程中最难解决的问题之一，尤其是在有很多关联对象的时候。这个困难在根本上在于无法确定调用方（caller）已经拥有了哪些锁。

&emsp;&emsp;你可能会锁定类x中的私有字段a，而并不知道调用方（或者调用方的调用方）已经锁住了类y中的字段b。同时，另一个线程正在执行顺序相反的操作，这样就创建了死锁。讽刺的是，这个问题会由于（良好的）面向对象的设计模式而加剧，因为这类模式建立的调用链直到运行时才能确定。

&emsp;&emsp;流行的建议：“以一致的顺序对对象加锁以避免死锁”，尽管它对于我们最初的例子有帮助，但是很难应用到刚才所描述的场景。更好的策略是：如果发现在锁区域中的对其它类的方法调用最终会引用回当前对象，就应该小心，同时考虑是否真的需要对其它类的方法调用加锁（往往是需要的，但是有时也会有其它选择）。更多的依靠声明方式（declarative）与数据并行（data parallelism）、不可变类型（immutable types）与非阻塞同步构造（ nonblocking synchronization constructs），可以减少对锁的需要。

>有另一种思路：当你在拥有锁的情况下访问其它类的代码，对于锁的封装就存在潜在的泄露。这不是 CLR 或 .NET Framework 的问题，而是因为锁本身的局限性。某些人认为造成这样问题的根因是可重入？

## 信号构造
**事件等待句柄（event wait handle）**：用于信号同步。信号同步就是一个线程进行等待，直到收到其他线程的通知的过程。它们有三个成员：AutoResetEvent、ManualResetEvent以及CountdownEvent( Framework 4.0 中加入)。
前两个的功能基本都是在它们的基类EventWaitHandle上实现的。

### AutoResetEvent
AutoResetEvent自动重置事件就是EventWaitHandle事件等待句柄的默认实现，如其命名，收到通知后他能自动复位（reset）。
调用WaitOne进入等待或者说阻塞，任意可访问的线程都能调用Set方法来放行。

```c#
EventWaitHandle waitHandle = new AutoResetEvent (false);
Task.Factory.StartNew(() =>
{
    _testOutputHelper.WriteLine("等待通知");
    waitHandle.WaitOne(); // 等待通知
    _testOutputHelper.WriteLine("接到通知");
    业务逻辑();
});
Thread.Sleep(1000);
_testOutputHelper.WriteLine("发送通知");
waitHandle.Set();
```