## 概要
**同步（synchronization）**：为期望的结果协调线程的行为。 当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。

**阻塞（block）**：当线程的执行由于某些原因被暂停，比如【信号构造】或【锁构造】时，比如调用Thread.Sleep，Task.Wait，或者通过Join方法等待其它线程结束时，则认为此线程被阻塞（blocked）。

阻塞会在以下 4 种情况下解除（电源按钮可不能算╮(╯▽╰)╭）：

* 阻塞条件被满足
* 操作超时（如果指定了超时时间）
* 通过Thread.Interrupt中断
* 通过Thread.Abort中止

**挂起（suspend）**：类似阻塞，但是不同于阻塞的是挂起会立刻让出（yields）其处理器时间片（timeslice），比如await（编译器将代码转换为状态机，它将跟踪类似：到达 await 时暂停执行以及后台作业完成时继续执行。从理论上讲，这是[异步的承诺模型](https://en.wikipedia.org/wiki/Futures_and_promises)的实现。）不要阻塞，而要 await！
```c#
static async Task<Toast> MakeToastWithButterAndJamAsync(int number)
{
    // do samething..
    var toast = await ToastBreadAsync(number);
    // do samething..
    return toast;
}
```
**锁构造（lock）**：锁能够限制同一时刻可以执行某些指令或是某段代码的线程数量。排他锁是最常见的，它只允许同一时刻至多有一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。
一般的排他锁有lock（Monitor.Enter/Monitor.Exit）、Mutex、SpinLock，非排他锁有Semaphore、SemaphoreSlim以及reader/writer lock。

**信号构造（signal）**：信号构造可以使一个线程【挂起】，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：事件等待句柄（event wait handle ）和Monitor类的Wait / Pulse方法。
Framework 4.0 加入了CountdownEvent与Barrier类。

**自旋（spinning）**：有时线程必须阻塞/暂停，直至条件被满足，【信号构造】或【锁构造】可以实现，但在等待条件能够在微秒级的时间被满足时，
自旋往往更加高效，因为它避免了上下文切换带来的昂贵开销。
```c#
while (!condition);
```
自旋往往与阻塞组合使用，防止cpu浪费
```c#
while (!condition) Thread.Sleep (10);
```
**线程状态（thread state）**：Unstarted、Running、WaitSleepJoin、Stopped。。