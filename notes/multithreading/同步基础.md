## 基本概念
**同步（synchronization）**：为期望的结果协调线程的行为。 当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。

**阻塞（block）**：当线程的执行由于某些原因被暂停，比如【信号构造】或【锁构造】时，比如调用Thread.Sleep，Task.Wait，或者通过Join方法等待其它线程结束时，则认为此线程被阻塞（blocked）。

阻塞会在以下 4 种情况下解除（电源按钮可不能算╮(╯▽╰)╭）：

* 阻塞条件被满足
* 操作超时（如果指定了超时时间）
* 通过Thread.Interrupt中断
* 通过Thread.Abort中止

**挂起（suspend）**：类似阻塞，但是不同于阻塞的是挂起会立刻让出（yields）其处理器时间片（timeslice），比如await（编译器将代码转换为状态机，它将跟踪类似：到达 await 时暂停执行以及后台作业完成时继续执行。从理论上讲，这是[异步的承诺模型](https://en.wikipedia.org/wiki/Futures_and_promises)的实现。）不要阻塞，而要 await！
```c#
static async Task<Toast> MakeToastWithButterAndJamAsync(int number)
{
    // do samething..
    var toast = await ToastBreadAsync(number);
    // do samething..
    return toast;
}
```
**锁构造（lock）**：锁能够限制同一时刻可以执行某些指令或是某段代码的线程数量。排他锁是最常见的，它只允许同一时刻至多有一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。
一般的排他锁有lock（Monitor.Enter/Monitor.Exit）、Mutex、SpinLock，非排他锁有Semaphore、SemaphoreSlim以及reader/writer lock。

**信号构造（signal）**：信号构造可以使一个线程【挂起】，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：事件等待句柄（event wait handle ）和Monitor类的Wait / Pulse方法。
Framework 4.0 加入了CountdownEvent与Barrier类。

**自旋（spinning）**：有时线程必须阻塞/暂停，直至条件被满足，【信号构造】或【锁构造】可以实现，但在等待条件能够在微秒级的时间被满足时，
自旋往往更加高效，因为它避免了上下文切换带来的昂贵开销。
```c#
while (!condition);
```
自旋往往与阻塞组合使用，防止cpu浪费
```c#
while (!condition) Thread.Sleep (10);
```
**线程状态（thread state）**：Unstarted、Running、WaitSleepJoin、Stopped。。

### Atomically

**原子性（atomically）**：如果一组变量总是在相同的【锁构造】内进行读写，就可以称为原子性读写
```c#
lock (locker) { if (x != 0) y /= x; }
```
可以说x和y是被原子的访问的，因为上面的代码块无法被其它的线程分割或抢占（cpu悲观锁/总线锁）。如果被其它线程分割或抢占，x和y就可能被别的线程修改导致计算结果无效（cpu乐观锁/缓存锁）。而现在 x和y总是在相同的排它锁中进行访问，因此不会出现除数为零的错误。

**指令原子性（instruction atomically）**：如果一条【指令】可以在 CPU 上不可分割地执行，那么它就是原子的

**指令（instruction）**：指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，CPU 通过【控制器单元】解析机器码来知道指令的内容。



## 锁
**同步对象（synchronized object）**：对所有参与同步的线程可见的任何对象都可以被当作同步对象使用，但有一个硬性规定：同步对象必须为引用类型。同步对象一般是私有的（因为这有助于封装锁逻辑），并且一般是一个实例或静态字段。同步对象也可以就是其要保护的对象。
```c#
class ThreadSafe
{
  List <string> _list = new List <string>();

  void Test()
  {
    lock (_list)
    {
      _list.Add ("Item 1");
      // ...
```
一个只被用来加锁的字段（例如前面例子中的_locker）可以精确控制锁的作用域与粒度。对象自己（this），甚至是类型，lambda 表达式或匿名方法所捕获的局部变量都可以被当作同步对象来使用：
```c#
lock (this) { ... }
// 或者：
lock (typeof (Widget)) { ... }    // 保护对静态资源的访问
```
这种方式的缺点在于并没有对锁逻辑进行封装，从而很难避免【死锁】与过多的【阻塞】。同时类型上的锁也可能会跨越应用程序域（application domain）边界（在同一进程内）。

### Monitor
C# 的lock语句是一个语法糖，它其实就是使用了try / finally来调用Monitor.Enter与Monitor.Exit方法：
```c#
bool taken = false;
try
{
    // JIT应该内联此方法，以便在典型情况下优化lockTaken参数的检查。
    Monitor.Enter(_locker,ref taken);
    num++;
}
finally
{
    // C# 4.0 解决锁泄露问题
    if (taken) Monitor.Exit(_locker);
}
```
Monitor是【可重入的（Reentrant）】,只有当最外层的lock语句退出或是执行了匹配数目的Monitor.Exit语句时，对象才会被解锁。
```c#
static void Main()
{
    lock (locker)  // 线程只会在第一个（最外层）lock处阻塞。
    {
        AnotherMethod();
        // 这里依然拥有锁，因为锁是可重入的
    }
}

static void AnotherMethod()
{
  lock (_locker) { Console.WriteLine ("Another method"); }
}
```
Monitor的性能：在一个 2010 时代的计算机上，没有竞争的情况下获取并释放锁一般只需 20 纳秒。如果存在竞争，产生的上下文切换会把开销增加到微秒的级别，并且线程被重新调度前可能还会等待更久的时间。如果需要锁定的时间很短，那么可以使用【自旋锁（SpinLock）】来避免上下文切换的开销。

Monitor还提供了一个TryEnter方法，允许以毫秒或是TimeSpan方式指定超时时间。如果获得了锁，该方法会返回true，而如果由于超时没有获得锁，则会返回false。TryEnter也可以以无参数的形式进行调用，这是对锁进行“测试”，如果不能立即获得锁就会立即返回false。

>如果获取锁后保持的时间太长而不释放，就会降低并发度，同时也会加大【死锁】的风险。

### Mutex

Mutex互斥体类似于Monitor，不同在于它是可以跨越进程工作。换句话说，Mutex可以是机器范围（computer-wide）的，也可以是程序范围（application-wide）的。

>没有竞争的情况下，获取并释放Mutex需要几微秒的时间，大约比lock慢 50 倍。

使用Mutex类时，可以调用WaitOne方法来加锁，调用ReleaseMutex方法来解锁。关闭或销毁Mutex会自动释放锁。与lock语句一样，Mutex只能被获得该锁的线程释放。

跨进程Mutex的一种常见的应用就是确保只运行一个程序实例。
```c#
// 命名的 Mutex 是机器范围的，它的名称需要是唯一的
// 比如使用公司名+程序名，或者也可以用 URL
using (var mutex = new Mutex (false, "oreilly.com OneAtATimeDemo"))
{
  // 可能其它程序实例正在关闭，所以可以等待几秒来让其它实例完成关闭
  if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false))
  {
    Console.WriteLine ("Another app instance is running. Bye!");
    return;
  }
  RunProgram();
}
```
>如果在终端服务（Terminal Services）下运行，机器范围的Mutex默认仅对于运行在相同终端会话的应用程序可见。要使其对所有终端会话可见，需要在其名字前加上Global\。
## 死锁

当两个线程等待的资源都被对方占用时（A等B，B等A），它们都无法执行，这就产生了死锁。更复杂的死锁链可能由三个或更多的线程创建。
```c#
object locker1 = new object();
object locker2 = new object();

new Thread(() =>
{
    lock (locker1)
    {
        Thread.Sleep(1000);
        lock (locker2)  // 死锁
        {
            // do something..
        }
    }
}).Start();

lock (locker2)
{
    Thread.Sleep(1000);
    lock (locker1)  // 死锁
    {
        // do something..
    }
}
```
CLR 不会像SQL Server一样自动检测和解决死锁。除非你指定了锁定的超时时间，否则死锁会造成参与的线程无限阻塞。（在SQL CLR 集成宿主环境中，死锁能够被自动检测，并在其中一个线程上抛出可捕获的异常。）

死锁是多线程中最难解决的问题之一，尤其是在有很多关联对象的时候。这个困难在根本上在于无法确定调用方（caller）已经拥有了哪些锁。

你可能会锁定类x中的私有字段a，而并不知道调用方（或者调用方的调用方）已经锁住了类y中的字段b。同时，另一个线程正在执行顺序相反的操作，这样就创建了死锁。讽刺的是，这个问题会由于（良好的）面向对象的设计模式而加剧，因为这类模式建立的调用链直到运行时才能确定。

流行的建议：“以一致的顺序对对象加锁以避免死锁”，尽管它对于我们最初的例子有帮助，但是很难应用到刚才所描述的场景。更好的策略是：如果发现在锁区域中的对其它类的方法调用最终会引用回当前对象，就应该小心，同时考虑是否真的需要对其它类的方法调用加锁（往往是需要的，但是有时也会有其它选择）。更多的依靠声明方式（declarative）与数据并行（data parallelism）、不可变类型（immutable types）与非阻塞同步构造（ nonblocking synchronization constructs），可以减少对锁的需要。

>有另一种思路：当你在拥有锁的情况下访问其它类的代码，对于锁的封装就存在潜在的泄露。这不是 CLR 或 .NET Framework 的问题，而是因为锁本身的局限性。某些人认为造成这样问题的根因是可重入？