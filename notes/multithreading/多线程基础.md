## 基本概念

**并发（multi threading）**：同一时间，多个线程运行同一块代码。多线程的目的就是为了并发，充分利用cpu多个核心，提高程序性能

**线程（thread）**：线程是操作系统能够进行运算调度的最小单位，被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

CLR 为每个线程分配各自独立的 **栈（stack）** 空间，因此局部变量是线程独立的。

```c#
static void Main()
{
  new Thread (Go).Start();      // 在新线程执行Go()
  Go();                         // 在主线程执行Go()
}

static void Go()
{
  // 定义和使用局部变量 - 'cycles'
  for (int cycles = 0; cycles < 5; cycles++) Console.Write ('?');
}
```
变量cycles的副本是分别在线程各自的栈中创建，因此会输出 10 个问号
```angular2html
??????????
```

线程可以通过对同一对象的引用来共享数据。例如：


```c#
static bool done;

static void Main()
{
  new Thread (tt.Go).Start();
  Go();
}

static void Go()
{
   if (!done) { 
      Console.WriteLine ("Done");
      done = true;
   }
}
```
这个例子引出了一个关键 **概念线程安全（thread safety）** ，由于并发，” Done “ 有可能会被打印两次

通过简单的加锁操作：在读写公共字段时，获得一个 **排它锁（互斥锁，exclusive lock ）** ，c#中使用lock即可生成 **临界区（critical section）** 
```c#
static readonly object locker = new object();
...
static void Go()
{
  lock (locker)
  {
    if (!done) { 
      Console.WriteLine ("Done");
      done = true;
    }
  }
}
```



**临界区（critical section）**：在同一时刻只有一个线程能进入，不允许并发。当有线程进入临界区段时，其他试图进入的线程或是进程必须 **等待或阻塞（blocking）**

**线程阻塞（blocking）**：指一个线程在执行过程中暂停，以等待某个条件的触发来解除暂停。阻塞状态的线程不会消耗CPU资源

可以通过调用Join方法等待线程执行结束，例如：
```c#
static void Main()
{
  Thread t = new Thread(Go);
  t.Start();
  t.Join();  // 等待线程 t 执行完毕
  Console.WriteLine ("Thread t has ended!");
}

static void Go()
{
  for (int i = 0; i < 1000; i++) Console.Write ("y");
}
```

也可以使用Sleep使当前线程阻塞一段时间：
```c#
Thread.Sleep (500);  // 阻塞 500 毫秒
```

> Thread.Sleep(0)会立即释放当前的时间片，将 CPU 资源出让给其它线程。Framework 4.0的Thread.Yield()方法与其大致相同，不同的是Yield()只会出让给运行在相同处理器核心上的其它线程。
>
> Sleep(0)和Yield在调整代码性能时偶尔有用，它也是一个很好的诊断工具，可以用于找出线程安全（thread safety）的问题。如果在你代码的任意位置插入Thread.Yield()会影响到程序，
> 基本可以确定存在 bug。


## 工作原理

### 硬件结构
https://xiaolincoding.com/os/1_hardware/how_cpu_run.html#%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F





